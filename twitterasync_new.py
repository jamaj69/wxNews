#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sat Nov 30 02:46:33 2019

@author: jamaj
"""
# NOTE: any reference to a `creds` variable in the documentation
# examples should have this format
import asyncio
from peony import EventStream, PeonyClient, event_handler, events
import redis
import time
import math
import uuid
import json
import logging
import sys

def acquire_lock_with_timeout(conn, lockname, acquire_timeout=10, lock_timeout=10):
   identifier = str(uuid.uuid4())
   #A 128-bit random identifier.

   lock_timeout = int(math.ceil(lock_timeout))
   #Only pass integers to our EXPIRE calls.
   end = time.time() + acquire_timeout
   while time.time() < end:

      if conn.setnx(lockname, identifier):
         conn.expire(lockname, lock_timeout)
         #Get the lock and set the expiration.
         return identifier
      elif not conn.ttl(lockname):
         conn.expire(lockname, lock_timeout)
         #Check and update the expiration time as necessary.

      time.sleep(.001)
   return False



def release_lock(conn, lockname, identifier):
    pipe = conn.pipeline(True)
    lockname = 'lock:' + lockname
    while True:
        try:
            pipe.watch(lockname)
            if pipe.get(lockname) == identifier:
                #Check and verify that we still have the lock.
                pipe.multi()
                pipe.delete(lockname)
                pipe.execute()
                return True
            #Release the lock.
            pipe.unwatch()
            break
        except redis.exceptions.WatchError:
            pass         
            #Someone else did something with the lock; retry.
    return False

def create_user(conn, login, name):
    llogin = login.lower()

    lock = acquire_lock_with_timeout(conn, 'user:' + llogin, 1)
    #Try to acquire the lock for the lowercased version of the login name. This function is defined in chapter 6.
    if not lock:
        return None
    #If we couldn’t get the lock, then someone else already has the same login name.
    userid = conn.hget('users:', llogin)
    print("userid",userid, "llogin:", llogin)
    if userid:
        id =  str(int(userid))
        print("UserID:",id)
        return id
    else:
        print("UserID:","new")
        

    #We also store a HASH of lowercased login names to user IDs, so if there’s already a login name that maps to an ID, we know and won’t give it to a second person.
    id = conn.incr('user:id:')
    #Each user is given a unique ID, generated by incrementing a counter.
    pipeline = conn.pipeline(True)
    pipeline.hset('users:', llogin, id)
    #Add the lowercased login name to the HASH that maps from login names to user IDs.

    pipeline.hmset('user:%s'%id, {
        'login': login,
        'id': id,
        'name': name,
        'followers': 0,
        'following': 0,
        'posts': 0,
        'signup': time.time(),
    #Add the user information to the user’s HASH.
    })

    pipeline.execute()
    release_lock(conn, 'user:' + llogin, lock)
    #Release the lock over the login name.
    print(id)
    return id



def create_status(conn, uid, message, data):
    pipeline = conn.pipeline(True)
    print('user:%s'%uid)
    pipeline.hget('user:%s'%uid, 'login')
    #Get the user’s login name from their user ID.

    pipeline.incr('status:id:')
    #Create a new ID for the status message.
    

    login, id = pipeline.execute()
    if not login:
        return None
    #Verify that we have a proper user account before posting.
    data.update({
        'message': message,
        'posted': time.time(),
        'id': id,
        'uid': uid,
        'login': login,
    })
    #print(data)
    pipeline.hmset('status:%s'%id, data)
    #Prepare and set the data for the status message.
    pipeline.hincrby('user:%s'%uid, 'posts')
    #Record the fact that a status message has been posted.
    pipeline.execute()
    return id
    
def ToString(value):
    tp = type(value)
    #print("Value type: ",tp)
    if tp == type(False):
        return 'True' if value else 'False'
    elif tp == type(None):
        return ''
    elif tp == type("") or tp == type(b''):
        return value
    elif tp == type([]):
        return str(value)
    elif tp == type({}):
        return ConvDictValuesToString(value)
    else:
        return str(value)
    
def ConvDictValuesToString(data):
   for key in data.keys():
       data[key] = ToString(data[key])  
   return data  
    
def ConvListValuesToString(data):
   for n in range(len(data)):
       data[n] = ToString(data[n])  
   return data  

#CONSUMER_KEY = '2qf6brDrwYNhURAnjtN4wWhYm'
#CONSUMER_SECRET = 'erZ2xOCAs84ghCSgLNvsatIwH0DkLUAui5BG6Z4mXkNIT4ElC2'
#ACCESS_TOKEN = '24987917-CNQzaHYoQfinoO0Op0aJavZR97HnYU3uMwbK4HexD'
#ACCESS_TOKEN_SECRET = 'AdBSPAstYghTepZzFnlrzsgnrXkzhpm9VzhxZTneen69I'

# Load credentials from environment
from decouple import config

CONSUMER_KEY = config('TWITTER_CONSUMER_KEY')
CONSUMER_SECRET = config('TWITTER_CONSUMER_SECRET')
ACCESS_TOKEN = config('TWITTER_ACCESS_TOKEN')
ACCESS_TOKEN_SECRET = config('TWITTER_ACCESS_TOKEN_SECRET')

conn = redis.Redis(host='localhost', port=6379, db=0)
 
 
creds = dict(consumer_key=CONSUMER_KEY,
             consumer_secret=CONSUMER_SECRET,
             access_token=ACCESS_TOKEN,
             access_token_secret=ACCESS_TOKEN_SECRET)


loop = asyncio.get_event_loop()

#client = PeonyClient(**creds,loads=json.loads)
client = PeonyClient(**creds)

USERIDS = [ '1201408473151496192','2923397967', '71567590', '24987917', '612896910', '1612504999', '15072071','41821987','41837261','348659640','59736898','219275799','18904582' ,'7996082','757809746','4898091']
# Languages to filter tweets by is a list. This will be joined by Twitter
# to return data mentioning tweets only in the english language.
LANGUAGES = None#['en', 'pt','ptbr']

async def get_home(since_id=None, **params):
    request = client.api.statuses.home_timeline.get(count=200, **params)
    responses = request.iterator.with_since_id()

    home = []
    async for tweets in responses:
        for tweet in reversed(tweets):
            text = html.unescape(tweet.text)
            print("@{user.screen_name}: {text}".format(user=tweet.user,
                                                       text=text))
            print("-"*10)

        await asyncio.sleep(120)
    return sorted(home, key=lambda tweet: tweet.id)


async def process_tweet(tweet):
    # you can then access items as you would do with a
    # `PeonyResponse` object
    user_id = tweet['user']['id_str']
    username = tweet.user.screen_name   
    description = tweet['user']['description']
    location = tweet['user']['location']
    followers_count = tweet['user']['followers_count']
    friends_count = tweet['user']['friends_count']
    listed_count = tweet['user']['listed_count']
    favourites_count = tweet['user']['favourites_count']
    statuses_count = tweet['user']['statuses_count']
    verified = tweet['user']['verified']
    twitter_id = tweet['id']
    twitter_ts = tweet['timestamp_ms']
    
    #tid_reply = tweet['in_reply_to_status_id_str']
    #tid_retweet = tweet['retweeted_status']
    #print('in_reply_to_status_id_str',':',tweet['in_reply_to_status_id_str'])
    #print('retweeted_status',':',tweet['retweeted_status'])
    
    #flds = ['in_reply_to_status_id_str','retweeted_status']
    #flds = ['in_reply_to_status_id_str']
    #for key in flds:
    #    if key in tweet.keys():
    #        print(key,':',tweet[key])
    
    #print(tweet)
    #for key in tweet.keys():
    #    print(key,':',tweet[key])
    hashtags = tweet['entities']['hashtags']
    user_mentions = tweet['entities']['user_mentions']
    urls = tweet['entities']['urls']
    retweeted_status = tweet['retweeted_status'] if 'retweeted_status' in tweet.keys() else ""
    in_reply_to_status_id_str = tweet['in_reply_to_status_id_str'] if 'in_reply_to_status_id_str' in tweet.keys() else ""
    
    
    #print('hashtags:',hashtags)
    #print('mentions:',user_mentions)
    #print('urls:',urls)
    #print('retweeted_status:',retweeted_status)
    lRetweet = False
    lReply = False
       
    if retweeted_status == None or retweeted_status == "" or retweeted_status == "None":
        pass
    else: 
        #print(type(retweeted_status))
        print("Retweet:",retweeted_status)
        twitter_id = retweeted_status['id_str']
        lRetweet = True
    
    in_reply_to_status_id_str = str(in_reply_to_status_id_str)
    if in_reply_to_status_id_str == None or in_reply_to_status_id_str == "" or in_reply_to_status_id_str == "None":
        pass
    else: 
        #print(type(in_reply_to_status_id_str))
        print("Reply:",in_reply_to_status_id_str)
        twitter_id = in_reply_to_status_id_str
        lReply = True
        
    
    if lRetweet or lReply:
        print("Retweet or reply")
        pass
    else:
        uid  = create_user(conn, user_id, username)
        #print(tweet)
        data = dict(**tweet)
        data = ToString(data)
        #print(data)
        sid =  create_status(conn, uid, tweet.text, data)
        twt = "uid:{uid} sid:{sid}" 
        print(twt.format(uid=uid,sid=sid))
        msg = "{tw_ts} ({tw_id}) | @{username} ({location})({id}): {text}"
        print(msg.format(tw_id = twitter_id,
                         tw_ts = twitter_ts,
                         location = location,
                         username=username,
                         id=user_id,
                         text=tweet.text))
    
    #for key in tweet.keys():
    #    print(key,':',tweet[key])
                      
    print("------------------------------------------------------")


async def  process(tweet):
    while True:
        tweet = yield
        await process_tweet(tweet)
    
    
    
async def tweet_processor(logger=None, ):
    if not logger:
        logger = logging.getLogger(__name__)
    while True:
        tweet = yield
        if tweet:
            logger.debug("Received tweet in tweet_processor().")
            await process_tweet(tweet)
    logger.debug("Exited from tweet_processor loop.") 
    

async def main(logger):
    req = client.stream.statuses.filter.post(follow=USERIDS)
    tw_proc = tweet_processor(logger=logger)
    await tw_proc.asend(None)                              
    # req is an asynchronous context
    async with req as stream:
        # stream is an asynchronous iterator
        async for tweet in stream:
            # check that you actually receive a tweet
            if events.tweet(tweet):
                await tw_proc.asend(tweet)                              
                                


logger = logging.getLogger(__name__)
logger.addHandler(logging.StreamHandler(sys.stdout))
logger.setLevel(logging.DEBUG)
try:
    asyncio.get_event_loop().run_until_complete(main(logger))
except KeyboardInterrupt:
    logger.info("Closed loop..")


if __name__ == '__main__':
    pass
