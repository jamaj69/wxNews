#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sat Nov 30 08:28:18 2019
@author: jamaj
"""
import redis
import time
import math
import uuid

def acquire_lock_with_timeout(conn, lockname, acquire_timeout=10, lock_timeout=10):
   identifier = str(uuid.uuid4())
   #A 128-bit random identifier.

   lock_timeout = int(math.ceil(lock_timeout))
   #Only pass integers to our EXPIRE calls.
   end = time.time() + acquire_timeout
   while time.time() < end:

      if conn.setnx(lockname, identifier):
         conn.expire(lockname, lock_timeout)
         #Get the lock and set the expiration.
         return identifier
      elif not conn.ttl(lockname):
         conn.expire(lockname, lock_timeout)
         #Check and update the expiration time as necessary.

      time.sleep(.001)
   return False



def release_lock(conn, lockname, identifier):
    pipe = conn.pipeline(True)
    lockname = 'lock:' + lockname
    while True:
        try:
            pipe.watch(lockname)
            if pipe.get(lockname) == identifier:
                #Check and verify that we still have the lock.
                pipe.multi()
                pipe.delete(lockname)
                pipe.execute()
                return True
            #Release the lock.
            pipe.unwatch()
            break
        except redis.exceptions.WatchError:
            pass         
            #Someone else did something with the lock; retry.
    return False

def create_user(conn, login, name):
    llogin = login.lower()

    lock = acquire_lock_with_timeout(conn, 'user:' + llogin, 1)
    #Try to acquire the lock for the lowercased version of the login name. This function is defined in chapter 6.
    if not lock:
        return None
    #If we couldn’t get the lock, then someone else already has the same login name.
    if conn.hget('users:', llogin):
        return None

    #We also store a HASH of lowercased login names to user IDs, so if there’s already a login name that maps to an ID, we know and won’t give it to a second person.
    id = conn.incr('user:id:')
    #Each user is given a unique ID, generated by incrementing a counter.
    pipeline = conn.pipeline(True)
    pipeline.hset('users:', llogin, id)
    #Add the lowercased login name to the HASH that maps from login names to user IDs.

    pipeline.hmset('user:%s'%id, {
        'login': login,
        'id': id,
        'name': name,
        'followers': 0,
        'following': 0,
        'posts': 0,
        'signup': time.time(),
    #Add the user information to the user’s HASH.
    })

    pipeline.execute()
    release_lock(conn, 'user:' + llogin, lock)
    #Release the lock over the login name.
    return id



def create_status(conn, uid, message, **data):
    pipeline = conn.pipeline(True)
    pipeline.hget('user:%s'%uid, 'login')
    #Get the user’s login name from their user ID.

    pipeline.incr('status:id:')
    #Create a new ID for the status message.
    

    login, id = pipeline.execute()
    if not login:
        return None
    #Verify that we have a proper user account before posting.
    data.update({
        'message': message,
        'posted': time.time(),
        'id': id,
        'uid': uid,
        'login': login,
    })

    pipeline.hmset('status:%s'%id, data)
    #Prepare and set the data for the status message.
    pipeline.hincrby('user:%s'%uid, 'posts')
    #Record the fact that a status message has been posted.
    pipeline.execute()
    return id
